/*
	source: https://www.youtube.com/watch?v=RlccXUx4LVw&list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1&index=48
		HTTP пакет складається з 3 частин:
			1) запит/відповідь - наприклад запит "GET" items/item (якщо зі сторони клієнта), або відповідь 200 OK (якщо зі сторони сервера)
			2) заголовки - може бути декілька, з версії HTTP 1.1 обов'язковий один: Host: www.google.com
			3) тіло - не обов'язково, якщо запит клієнта то тут передаються параметри, а якщо відповідь сервера - то сторінка

		Заголовки:
			- Host: www.google.com - вказується доменне ім'я сервера, в якого просимо сторінку, причина - на одному IP може бути декілька серверів
			- Content-Type: text/html; charset=UTF-8 - тип вмісту
			- Content-Length: 5161 - розмір даних, що надсилаються (5161 байт)
			- Upgrade: websocket - говорить серверу, що протокол треба оновити/змінити на websocket 

		Клієнти в запиті вказує метод, існують такі методи:
		 	- GET - запит на передачу сторінки
			- POST - передача даних на web-сервер для обробки
			- HEAD - просить заголовок сторінки - те саме що і GET тільки без тіла повідомлення
			- PUT - розміщення ресурсу на web-сервері - треба мати спеціальні права доступа
			- DELETE - видалення ресурсу з web-сервера - треба мати спеціальні права доступа
			- TRACE - дозволяє відслідковувати що відбувається із сторінкою хто вносить в неї які зміни
			- OPTIONS - дозволяє дізнатись які методи підтримуються для конкретного ресурсу на web- сервері
			- CONNECT - дозволяє підключитись до web-сервера через proxy

		Відповідь сервера - перше поле завжди статус обробки запиту є всього 5 груп 1xx - 5xx
			- 1xx - передача інформаційних повідомлень
			- 2хх - запит виконано успішно
				- 200 - означає, що сторінка знайдена і вона передається клієнту
			- 3хх - інформація про перенаправлення
				- 301 - постійний редірект, говорить нам про те, що сторінка була переміщена на іншу адресу і всі наступні запити
					мають йти на цю нову адресу
				- 307 - тимчасовий редірект, тобто зараз доступ до сторінки отримуємо з іншої адреси, але через деякий час треба
					знову звертатись за старою адресою
			- 4хх - повідомлення про помилку на стороні клієнта
				- 404 - сторінку, яку запросив клієнт - не знайдена на сервері
				- 403 - доступ до ресурса заборонений
			- 5хх - помилка на стороні сервера
				- 500 - внутрішня помилка сервера

		Приклад запиту і відповіді HTTP:
			- нам треба підключитись до сервера www.google.com, до порта 80 по протоколу TCP
			- створюється TCP з'єднання
			- пишемо запит
				- юзаємо метод GET
				- хочем отримати ресурс /items/item
				- вказуємо версію протоколу, по якому ми хочемо працювати HTTP 1.1
				- для цієї версії є 1 обов'язковий заголовок Host: www.google.com
			- на це сервер відповідає
				- відповідь серверу починається з вказання версії протоколу, що використовується, тобто HTTP 1.1
				- потім - вказується статус 200 OK - обробка запиту пройшла успішно
				- далі йдуть декілька заголовків:
					- Server: nginx - реалізація web-сервера
					- Content-Type: text/html; charset=UTF-8 - тип і кодування сторінки, що передається
					- Content-Length: 5161 - розмір сторінки 5161 байт
				- далі йде ПУСТА СТРОКА
				- далі йде вміст web-сторінки
				- після передачі web-сторінки з'єднання TCP розривається



	source: https://www.youtube.com/watch?v=7DitlqcesKI&list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1&index=49
		Послідовність виконання запиту:
			1) встановлення TCP з'єднання
			2) запит по протоколу HTTP
			3) відповідь сервера - повертає сторінку
			4) з'єднання TCP закривається
			5) браузер дивиться вміст сторінки, бачить що треба грузить ще багато ресурсів (CSS, JS, картинки)
			6) відкривається нове TCP з'єднання для завантаження CSS файлу
			7) клієнт шле запит на файл CSS
			8) сервер відповідає - віддає файл CSS
			9) TCP з'єднання знову закривається
			і так по кожному ресурсу

		Можна відкрити таке TCP з'єднання, яке дозволяє передати всі ресурси і тільки потім закритися - HTTP keep-alive
			- для HTTP 1.0 така можливість надається за допомогою заголовка Connection: keep-alive
			- коли клієнт задає такий заголовок - він просить сервер не закривати TCP з'єднання
				після відправки відповіді, якщо сервер розуміє цей заголовок і підтримує постійне з'єднання - він залишає з'єднання
				відкритим і додає цей заголовок у відповідь

		Приклад використання заголовку:
			шлемо запит HTTP по протоколу HTTP 1.0, методом GET, хочемо отримати сторінку /items/item, заголовки:
				Host: www.google.com - обов'язковий заголовок
				Connection: keep-alive - просимо сервер не закривати TCP з'єднання
			сервер присилає відповідь:
				HTTP/1.0 200 OK - статус, сторінка знайдена
				Server: nginx
				Content-Type: text/html; charset=UTF-8
				Content-Length: 5161
				Connection: keep-alive - означає, що сервер підтримує постійне з'єднання і лишив з'єднання відкритим

		В стандарті HTTP 1.1 по дефолту всі з'єднання ПОСТІЙНІ тому юзать заголовок Connection: keep-alive не обов'язково

		Якщо клієнт хоче розірвати з'єднання - може використати заголовок Connection: close



	source: https://www.youtube.com/watch?v=esi6YZRvJzk&list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1&index=50
		Протокол HTTP підтримує роботу кеша, основна проблема - браузер має визначити чи брати ресурс з кешу, чи ресурс
			змінився і його треба заново завантажити, для цього існує спеціальний заголовок
		Expires: Sun, 12 Jun 2016 10:35:18 GMT - цей заголовок сервер додає у відповідь і в ньому міститься інфа до
			якого часу можна зберігати ресурс в кеші
		Не всі сервери встановлюють цей заголовок

		В HTTP протоколі є і інший підхід, який дозволяє визначити змінився ресурс чи ні, для цього клієнт має відправити
			серверу запит GET з умовою (Conditional GET) - у відповідь сервер може сказати, що сторінка не змінилась, тоді
			браузер бере ресурс з кешу, а якщо сторінка змінилась, то сервер віддасть змінену версію сторінки

		Приклад Conditional GET
			- при першому запиті браузер шле звичайний GET запит і зберігає результат в кеші
			- Conditional GET можна юзать тільки якщо у відповіді сервер встановив заголовок Last-Modified із датою
				останньої зміни ресурсу
			- наступного разу коли браузер буде звертатись до сервера за тим самим ресурсом, він вже буде юзать
				запит Conditional GET і додасть в запит додатковий заголовок If-Modified-Since: Wed, 25 May 2016 06:13:24 GMT
				ця дата якраз береться з заголовка Last-Modified з минулої відповіді сервера
			- сервер може дати 2 варіанта відповіді на Conditional GET запит:
				- якщо ресурс не змінився - сервер кидає коротке повідомлення із статусом 304 Not modified, ця відповідь
					може включати додаткові заголовки по керуванню кешем (Expires, Last-Modified, Cache-Control), сам
					ресурс не передається
				- якщо ресурс змінився - сервер кидає респонс з статусом 200 ОК і ресурс передається повністю

		В протоколі HTTP 1.1 є додаткова можливість перевірити чи змінився ресурс, для цього юзається etag (Entity Tag)
			це спеціальний код, що генерується на основі змісту ресурсу, web сервер при відправці ресурсу додає цей код
			в спеціальному заголовку etag: "57454284-3d8f", якщо ресурс змінився, то значення etag також зміниться
		Для використання Conditional GET з кодом etag ми маємо юзать замість заголовку If-Modified-Since,
			заголовок If-None-Match: 57454284-3d8f

		В протоколі HTTP 1.1 також з'явився новий заголовок Cache-Control: private, max-age=10 для більш гнучкого
			керування кешуванням, він може містити декілька різних елементів:
			- no-store - говорить, що ресурс неможна зберігати в кеш
			- no-cache - ресурс зберігати в кеш можна, але для цього треба виконати запит Conditional GET і слідкувати
				чи ресурс змінився на сервері так само за допомогою Conditional GET
			- public - інфа може бути доступна всім і її можна кешувати
			- private - інфа може бути збережена тільки в локальному кеші браузера
			- max-age - встановлює час зберігання ресурса в кеші в секундах, використовується для заміни заголовка Expires
*/

console.log('GOOD');
